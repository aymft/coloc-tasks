<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Housemates â€” Tasks</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    body { margin: 0; background:#0b0d12; color:#e8ebf2; }
    header { padding: 18px 20px; border-bottom: 1px solid #22283a; background:#0f1320; position: sticky; top:0; }
    h1 { margin: 0; font-size: 18px; }
    .sub { margin-top: 6px; color:#aeb6d2; font-size: 13px; }
    main { padding: 18px 20px; max-width: 1100px; margin: 0 auto; }
    .row { display:flex; gap:12px; flex-wrap: wrap; align-items:center; }
    button {
      background:#2a6cff; color:white; border:0; padding:10px 12px;
      border-radius: 10px; cursor:pointer; font-weight: 600;
    }
    button.secondary { background:#1b2236; color:#d7def7; border:1px solid #2a365a; }
    button:disabled { opacity:.55; cursor:not-allowed; }
    .card {
      background:#0f1320; border:1px solid #22283a; border-radius: 14px;
      padding: 14px; margin: 12px 0;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }
    .grid { display:grid; grid-template-columns: 1fr; gap:12px; }
    @media (min-width: 900px) { .grid { grid-template-columns: 1.2fr .8fr; } }
    table { width:100%; border-collapse: collapse; }
    th, td { padding: 10px 8px; border-bottom: 1px solid #22283a; font-size: 14px; vertical-align: top; }
    th { text-align:left; color:#aeb6d2; font-weight: 700; }
    .pill { display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border-radius:999px; border:1px solid #2a365a; background:#121a2f; }
    .muted { color:#aeb6d2; }
    .small { font-size: 12px; }
    .task { display:flex; gap:10px; align-items:flex-start; margin: 6px 0; }
    .task label { cursor:pointer; }
    .kpi { display:flex; gap:10px; flex-wrap: wrap; }
    .kpi .box { padding:10px 12px; border:1px solid #22283a; border-radius: 12px; background:#0c1020; min-width:190px; }
    .ok { color:#6ee7b7; font-weight: 700; }
    .warn { color:#fde68a; font-weight: 700; }
    details summary { cursor:pointer; color:#d7def7; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .right { text-align:right; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #2a365a; background:#121a2f; }
    .notice { border:1px solid #2a365a; background:#121a2f; border-radius:12px; padding:10px 12px; }
    .pink { color:#ff66cc; font-weight:800; }
    .green { color:#6ee7b7; font-weight:800; }
    .yellow { color:#fde68a; font-weight:800; }
  </style>
</head>

<body>
<header>
  <h1>Housemates â€” Task Tracking</h1>
  <div class="sub" id="weekLine"></div>
</header>

<main>
  <div class="row">
    <button id="btnGenerate">Recompute this week</button>
    <button class="secondary" id="btnRecapCopy">Weekly recap (copy)</button>
    <button class="secondary" id="btnRecapWA">Weekly recap (WhatsApp)</button>
    <button class="secondary" id="btnExport">Export JSON (week)</button>
    <span class="muted small" id="status"></span>
  </div>

  <!-- Admin-only absences -->
  <section class="card" id="absencesPanel" style="display:none;">
    <h2 style="margin:0 0 10px 0; font-size:16px;">Absences (admin only)</h2>
    <div class="muted small">
      Mark who is away this week, then click <b>Save absences + recompute</b>.
      Away people receive <b>no tasks</b>.
      If someone returns after being away last week, their <b>done score</b> is set to the <b>average of present people</b>.
    </div>
    <div id="absences" style="margin-top:10px;"></div>
    <div class="row" style="margin-top:12px;">
      <button class="secondary" id="btnSaveAbsences">Save absences + recompute</button>
    </div>
    <div class="muted small" style="margin-top:10px;">
      Admin link example: <span class="mono">.../#admin=TiensVoilaDuBoudin</span>
    </div>
  </section>

  <div class="grid">
    <section class="card">
      <h2 style="margin:0 0 10px 0; font-size:16px;">This weekâ€™s schedule</h2>
      <div class="muted small" style="margin-bottom:12px;">
        Main score uses <b>done points only</b> (points count only when checked).
        Everyone sees the same schedule all week.
      </div>
      <div id="schedule"></div>
    </section>

    <aside class="card">
      <h2 style="margin:0 0 10px 0; font-size:16px;">Scores</h2>
      <div class="notice muted small" style="margin-bottom:10px;">
        <span class="pink">bitch</span> appears if you did <b>not</b> finish all your tasks in the <b>last finished week</b>.
      </div>
      <div class="kpi" id="kpis"></div>
    </aside>
  </div>

  <section class="card">
    <details>
      <summary>History (points per week)</summary>
      <div id="history"></div>
    </details>
  </section>
</main>

<script type="module">
  import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

  /** =======================
   *  CONFIG
   *  ======================= */
  const SUPABASE_URL = "https://cakvyvxclyjqfbacqrzg.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNha3Z5dnhjbHlqcWZiYWNxcnpnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njk5NDY1NTcsImV4cCI6MjA4NTUyMjU1N30.p447fGnnhR8nS8EDSVsfMaP9eVfpQB2FscuyQC-65B4";
  const ROOM_KEY = "coloc-xxxxx"; // MUST match your SQL policies

  const TABLE = "coloc_weeks";
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  // Meta row key (stores done offsets)
  const META_WEEK_KEY = "__meta__";

  // ADMIN secret in URL hash: #admin=TiensVoilaDuBoudin
  const ADMIN_SECRET = "TiensVoilaDuBoudin";

  function getHashParam(key) {
    const h = (location.hash || "").replace(/^#/, "");
    const params = new URLSearchParams(h);
    return params.get(key);
  }
  function isAdmin() {
    return getHashParam("admin") === ADMIN_SECRET;
  }

  /** =======================
   *  Data
   *  ======================= */
  const PEOPLE = ["Andrea","Aditya","Aymeric","Francesco","Marco","Leonardo"];

  const BATHROOMS = {
    "Bathroom 1 (Adi/Aymeric/Francesco)": ["Aditya","Aymeric","Francesco"],
    "Bathroom 2 (Andrea/Marco/Leonardo)": ["Andrea","Marco","Leonardo"]
  };

  const COMMON_TASKS = [
    { id:"surfaces_salon", name:"Living room surfaces", pts:2, pool:"all" },
    { id:"surfaces_cuisine", name:"Kitchen surfaces", pts:4, pool:"all" },
    { id:"aspirateur_salon_couloir", name:"Vacuum living room + hallway", pts:5, pool:"all" },
    { id:"aspirateur_cuisine", name:"Vacuum kitchen", pts:2, pool:"all" },
    { id:"serpilliere_salon_couloir", name:"Mop living room + hallway", pts:5, pool:"all" },
    { id:"serpilliere_cuisine", name:"Mop kitchen", pts:2, pool:"all" },
  ];

  const BATHROOM_TASKS = [
    { id:"sdb_sol", name:"Bathroom: vacuum + mop", pts:2 },
    { id:"sdb_surfaces", name:"Bathroom: surfaces", pts:5 },
  ];

  /** =======================
   *  Time helpers / ISO week (Europe/Rome)
   *  ======================= */
  function isoWeekKey(date = new Date()) {
    const romeStr = date.toLocaleString("sv-SE", { timeZone: "Europe/Rome" });
    const d = new Date(romeStr.replace(" ", "T") + "Z");

    const tmp = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
    const dayNum = tmp.getUTCDay() || 7;
    tmp.setUTCDate(tmp.getUTCDate() + 4 - dayNum);
    const yearStart = new Date(Date.UTC(tmp.getUTCFullYear(),0,1));
    const weekNo = Math.ceil((((tmp - yearStart) / 86400000) + 1) / 7);
    const year = tmp.getUTCFullYear();
    return `${year}-W${String(weekNo).padStart(2,"0")}`;
  }

  /** =======================
   *  Meta offsets (for return fairness)
   *  ======================= */
  function ensureMetaLocal(allWeeks) {
    if (!allWeeks[META_WEEK_KEY]) allWeeks[META_WEEK_KEY] = { offsets_done: {} };
    allWeeks[META_WEEK_KEY].offsets_done ||= {};
    for (const p of PEOPLE) {
      if (typeof allWeeks[META_WEEK_KEY].offsets_done[p] !== "number") {
        allWeeks[META_WEEK_KEY].offsets_done[p] = 0;
      }
    }
  }

  function applyOffsetsDone(totals, allWeeks) {
    ensureMetaLocal(allWeeks);
    const offsets = allWeeks[META_WEEK_KEY].offsets_done || {};
    for (const p of PEOPLE) totals[p].done += (offsets[p] || 0);
    return totals;
  }

  async function saveMeta(allWeeks) {
    ensureMetaLocal(allWeeks);
    await upsertWeek(META_WEEK_KEY, allWeeks[META_WEEK_KEY]);
  }

  /** =======================
   *  Totals (assigned + done)
   *  ======================= */
  function computeTotals(allWeeks) {
    const totals = {};
    PEOPLE.forEach(p => totals[p] = { assigned:0, done:0 });

    const keys = Object.keys(allWeeks).filter(k => k !== META_WEEK_KEY).sort();
    for (const wk of keys) {
      const w = allWeeks[wk];
      for (const a of (w.assignments || [])) {
        totals[a.person].assigned += a.pts;
        if (w.done && w.done[a.taskKey]) totals[a.person].done += a.pts;
      }
    }
    return applyOffsetsDone(totals, allWeeks);
  }

  function totalsBeforeWeek(allWeeks, weekKey) {
    const totals = {};
    PEOPLE.forEach(p => totals[p] = { assigned:0, done:0 });

    const keys = Object.keys(allWeeks).filter(k => k !== META_WEEK_KEY).sort();
    for (const wk of keys) {
      if (wk >= weekKey) break;
      const w = allWeeks[wk];
      for (const a of (w.assignments || [])) {
        totals[a.person].assigned += a.pts;
        if (w.done && w.done[a.taskKey]) totals[a.person].done += a.pts;
      }
    }
    return applyOffsetsDone(totals, allWeeks);
  }

  /** =======================
   *  Absences + return logic
   *  ======================= */
  function getActivePeople(absentList) {
    const absent = new Set(absentList || []);
    return PEOPLE.filter(p => !absent.has(p));
  }

  function lastWeekKeyBefore(allWeeks, weekKey) {
    const keys = Object.keys(allWeeks).filter(k => k !== META_WEEK_KEY).sort();
    let prev = null;
    for (const k of keys) {
      if (k < weekKey) prev = k; else break;
    }
    return prev;
  }

  function computeReturningPeople(allWeeks, weekKey, absentNow) {
    const prevKey = lastWeekKeyBefore(allWeeks, weekKey);
    if (!prevKey) return [];
    const prevAbsent = new Set(allWeeks[prevKey]?.absent || []);
    const nowAbsent = new Set(absentNow || []);
    return PEOPLE.filter(p => prevAbsent.has(p) && !nowAbsent.has(p));
  }

  function setReturnersToAverageDone(allWeeks, weekKey, absentNow) {
    // adjust offsets so returners' done totals == avg(done of present others)
    ensureMetaLocal(allWeeks);

    const returners = computeReturningPeople(allWeeks, weekKey, absentNow);
    if (!returners.length) return;

    const totals = computeTotals(allWeeks); // includes existing offsets
    const active = getActivePeople(absentNow);

    for (const r of returners) {
      const others = active.filter(p => p !== r);
      if (!others.length) continue;

      const avg = others.reduce((s,p) => s + totals[p].done, 0) / others.length;
      const current = totals[r].done;

      const delta = avg - current; // could be positive or negative
      allWeeks[META_WEEK_KEY].offsets_done[r] = (allWeeks[META_WEEK_KEY].offsets_done[r] || 0) + delta;
    }
  }

  /** =======================
   *  Assignment helpers
   *  ======================= */
  function assignTasksGreedy(tasks, eligiblePeople, baseScoreMap) {
    const sorted = [...tasks].sort((a,b) => (b.pts - a.pts) || (a.taskKey||"").localeCompare(b.taskKey||""));
    const pool = [...eligiblePeople];
    if (!pool.length) return [];

    const score = { ...baseScoreMap };
    const out = [];

    for (const t of sorted) {
      pool.sort((p1,p2) => score[p1] - score[p2] || p1.localeCompare(p2));
      const pick = pool[0];
      out.push({ ...t, person: pick });
      score[pick] += t.pts;
    }
    return out;
  }

  function assignCommonOneEach(commonTasksWithKeys, peoplePool, baseScoreMap) {
    const pool = [...peoplePool];
    if (!pool.length) return [];

    const tasks = [...commonTasksWithKeys].sort((a,b) => b.pts - a.pts || a.taskKey.localeCompare(b.taskKey));
    const score = { ...baseScoreMap };

    const k = Math.min(pool.length, tasks.length);
    const peopleSorted = [...pool].sort((p1,p2) => score[p1] - score[p2] || p1.localeCompare(p2));

    const assignments = [];
    for (let i=0; i<k; i++) {
      const p = peopleSorted[i];
      const t = tasks[i];
      assignments.push({ ...t, person: p });
      score[p] += t.pts;
    }

    const remaining = tasks.slice(k);
    if (remaining.length) {
      assignments.push(...assignTasksGreedy(remaining, pool, score));
    }
    return assignments;
  }

  function buildWeekState(allWeeks, weekKey) {
    const existing = allWeeks[weekKey] || {};
    const absentList = existing.absent || [];
    const activePeople = getActivePeople(absentList);

    // baseScoreMap = done totals before this week (for balancing)
    const totalsPrev = totalsBeforeWeek(allWeeks, weekKey);
    const baseScoreMap = {};
    for (const p of PEOPLE) baseScoreMap[p] = totalsPrev[p].done;

    // Common: ensure 1 task each among active (as much as possible)
    const commonAssignments = assignCommonOneEach(
      COMMON_TASKS.map(t => ({...t, taskKey:`all:${t.id}`})),
      activePeople,
      baseScoreMap
    );

    // Bathrooms: assign within bathroom if possible, else fallback to active people
    const bathroomAssignments = [];
    for (const [bathName, members] of Object.entries(BATHROOMS)) {
      const tasks = BATHROOM_TASKS.map(t => ({
        id: t.id,
        name: `${t.name} â€” ${bathName}`,
        pts: t.pts,
        pool: bathName,
        taskKey: `bath:${bathName}:${t.id}`
      }));

      const pool = members.filter(m => activePeople.includes(m));
      const usePool = pool.length ? pool : activePeople;

      bathroomAssignments.push(...assignTasksGreedy(tasks, usePool, baseScoreMap));
      // update baseScoreMap so later assignments see updated loads
      for (const a of bathroomAssignments) baseScoreMap[a.person] += 0; // (kept simple; common already handled)
    }

    const assignments = [...commonAssignments, ...bathroomAssignments].map(a => ({
      taskKey: a.taskKey,
      taskName: a.name,
      pts: a.pts,
      person: a.person,
      pool: a.pool ?? "all"
    }));

    // keep done map but drop keys that no longer exist (after recompute)
    const existingDone = existing.done || {};
    const validKeys = new Set(assignments.map(a => a.taskKey));
    const prunedDone = {};
    for (const [k,v] of Object.entries(existingDone)) if (validKeys.has(k)) prunedDone[k] = !!v;

    return {
      assignments,
      done: prunedDone,
      absent: absentList,
      createdAt: existing.createdAt || new Date().toISOString()
    };
  }

  /** =======================
   *  DB
   *  ======================= */
  const $status = document.getElementById("status");
  function setStatus(msg) { $status.textContent = msg; }

  async function fetchAllWeeks() {
    const { data, error } = await supabase
      .from(TABLE)
      .select("week_key,state,updated_at")
      .eq("room_key", ROOM_KEY)
      .order("week_key", { ascending: true });

    if (error) throw error;

    const map = {};
    for (const row of data) map[row.week_key] = row.state;
    ensureMetaLocal(map);
    return map;
  }

  async function fetchWeekState(weekKey) {
    const { data, error } = await supabase
      .from(TABLE)
      .select("state")
      .eq("room_key", ROOM_KEY)
      .eq("week_key", weekKey)
      .single();

    if (error) throw error;
    return data.state;
  }

  async function upsertWeek(weekKey, state) {
    const payload = { room_key: ROOM_KEY, week_key: weekKey, state, updated_at: new Date().toISOString() };
    const { error } = await supabase.from(TABLE).upsert(payload);
    if (error) throw error;
  }

  async function insertWeekOnce(weekKey, state) {
    const { error } = await supabase.from(TABLE).insert({
      room_key: ROOM_KEY,
      week_key: weekKey,
      state,
      updated_at: new Date().toISOString()
    });
    return error; // null if OK
  }

  async function updateDone(weekKey, doneMap) {
    const state = await fetchWeekState(weekKey);
    state.done = doneMap;
    state.updatedAt = new Date().toISOString();
    await upsertWeek(weekKey, state);
  }

  /** =======================
   *  â€œBitchâ€ logic (last finished week = previous week)
   *  ======================= */
  function lastFinishedWeekKey(allWeeks, currentWeekKey) {
    const keys = Object.keys(allWeeks).filter(k => k !== META_WEEK_KEY).sort();
    let last = null;
    for (const k of keys) {
      if (k < currentWeekKey) last = k; else break;
    }
    return last;
  }

  function isBitchForWeek(weekState, person) {
    const tasks = (weekState.assignments || []).filter(a => a.person === person);
    if (!tasks.length) return false;
    return tasks.some(t => !(weekState.done && weekState.done[t.taskKey]));
  }

  /** =======================
   *  Weekly recap
   *  ======================= */
  function buildWeeklyRecap(allWeeks, currentWeekKey) {
    const wk = lastFinishedWeekKey(allWeeks, currentWeekKey);
    if (!wk) return "No finished week yet.";
    const w = allWeeks[wk];

    const lines = [];
    lines.push(`ðŸ§¹ Weekly recap â€” ${wk}`);

    for (const p of PEOPLE) {
      const assigned = (w.assignments || []).filter(a => a.person === p);
      const done = assigned.filter(a => w.done && w.done[a.taskKey]);
      const missing = assigned.filter(a => !(w.done && w.done[a.taskKey]));
      const ptsDone = done.reduce((s,x)=>s+x.pts,0);
      const ptsAss = assigned.reduce((s,x)=>s+x.pts,0);

      lines.push(`\n${p}: ${ptsDone}/${ptsAss} pts`);
      lines.push(`âœ… Done: ${done.length ? done.map(x=>x.taskName).join(", ") : "(none)"}`);
      if (missing.length) lines.push(`âŒ Missing: ${missing.map(x=>x.taskName).join(", ")}`);
    }

    const bitchList = PEOPLE.filter(p => isBitchForWeek(w, p));
    if (bitchList.length) lines.push(`\nðŸ’— Bitch list: ${bitchList.join(", ")}`);
    return lines.join("\n");
  }

  async function copyToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
      return true;
    } catch (e) {
      // fallback
      const ta = document.createElement("textarea");
      ta.value = text;
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      document.body.removeChild(ta);
      return true;
    }
  }

  function openWhatsAppShare(text) {
    const url = "https://wa.me/?text=" + encodeURIComponent(text);
    window.open(url, "_blank", "noopener,noreferrer");
  }

  /** =======================
   *  UI
   *  ======================= */
  function renderAbsencesPanel(weekKey, allWeeks) {
    const week = allWeeks[weekKey];
    const absent = new Set(week.absent || []);
    const wrap = document.getElementById("absences");
    wrap.innerHTML = "";

    for (const p of PEOPLE) {
      const line = document.createElement("div");
      line.className = "task";
      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = absent.has(p);
      cb.dataset.person = p;
      const lab = document.createElement("label");
      lab.textContent = `${p} is away this week`;
      line.appendChild(cb);
      line.appendChild(lab);
      wrap.appendChild(line);
    }
  }

  function render(weekKey, allWeeks) {
    const week = allWeeks[weekKey];
    const absentList = week.absent || [];
    const absentText = absentList.length ? ` â€” away: <span class="mono">${absentList.join(", ")}</span>` : "";
    const adminBadge = isAdmin() ? ` â€” <span class="badge mono">ADMIN</span>` : ` â€” <span class="badge mono">USER</span>`;

    document.getElementById("weekLine").innerHTML =
      `Current week: <span class="mono badge">${weekKey}</span> â€” timezone Europe/Rome${adminBadge}${absentText}`;

    // by person
    const byPerson = {};
    PEOPLE.forEach(p => byPerson[p] = []);
    for (const a of week.assignments) byPerson[a.person].push(a);
    for (const p of PEOPLE) byPerson[p].sort((x,y) => y.pts - x.pts);

    const scheduleDiv = document.getElementById("schedule");
    scheduleDiv.innerHTML = "";

    const table = document.createElement("table");
    table.innerHTML = `
      <thead>
        <tr>
          <th>Person</th>
          <th>Tasks</th>
          <th class="right">Done / Assigned (week)</th>
        </tr>
      </thead>
    `;
    const tbody = document.createElement("tbody");

    for (const p of PEOPLE) {
      const tasks = byPerson[p];
      const ptsAssigned = tasks.reduce((s,t)=>s+t.pts,0);
      const ptsDone = tasks.reduce((s,t)=> s + (week.done?.[t.taskKey] ? t.pts : 0), 0);

      const tdTasks = document.createElement("td");
      for (const t of tasks) {
        const wrap = document.createElement("div");
        wrap.className = "task";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = !!week.done?.[t.taskKey];
        cb.addEventListener("change", async () => {
          const newDone = { ...(week.done || {}) };
          newDone[t.taskKey] = cb.checked;
          week.done = newDone;

          setStatus("Savingâ€¦");
          try {
            await updateDone(weekKey, newDone);
            setStatus("OK (synced)");
            renderScores(allWeeks, weekKey);
          } catch (e) {
            console.error(e);
            setStatus("Save error");
            alert("Error: could not save. See console.");
          }
        });

        const label = document.createElement("label");
        label.innerHTML = `<span>${t.taskName}</span> <span class="muted small">(${t.pts} pts)</span>`;
        wrap.appendChild(cb);
        wrap.appendChild(label);
        tdTasks.appendChild(wrap);
      }

      const tr = document.createElement("tr");
      const tdP = document.createElement("td");
      tdP.innerHTML = `<span class="pill"><b>${p}</b></span>`;
      const tdPts = document.createElement("td");
      tdPts.className = "right";
      tdPts.innerHTML = `<b>${ptsDone}</b><span class="muted small"> / ${ptsAssigned}</span>`;

      tr.appendChild(tdP);
      tr.appendChild(tdTasks);
      tr.appendChild(tdPts);
      tbody.appendChild(tr);
    }

    table.appendChild(tbody);
    scheduleDiv.appendChild(table);

    renderScores(allWeeks, weekKey);
    renderHistory(allWeeks, weekKey);

    if (isAdmin()) renderAbsencesPanel(weekKey, allWeeks);
  }

  function renderScores(allWeeks, currentWeekKey) {
    const kpis = document.getElementById("kpis");
    kpis.innerHTML = "";

    const totals = computeTotals(allWeeks);
    const doneValues = PEOPLE.map(p => totals[p].done);
    const min = Math.min(...doneValues);
    const max = Math.max(...doneValues);

    const lastWk = lastFinishedWeekKey(allWeeks, currentWeekKey);
    const lastState = lastWk ? allWeeks[lastWk] : null;

    for (const p of PEOPLE) {
      const vDone = totals[p].done;
      const status = (vDone === min) ? "ok" : (vDone === max ? "warn" : "");
      const bitch = lastState ? isBitchForWeek(lastState, p) : false;
      const bitchBadge = bitch ? `<span class="pink" style="margin-left:6px;">bitch</span>` : "";

      const box = document.createElement("div");
      box.className = "box";
      box.innerHTML = `
        <div><b>${p}</b>${bitchBadge}</div>
        <div class="mono ${status}" style="font-size:16px;">${Math.round(vDone*100)/100} done pts</div>
        <div class="muted small">assigned total: ${totals[p].assigned}</div>
      `;
      kpis.appendChild(box);
    }
  }

  function renderHistory(allWeeks, currentWeekKey) {
    const histDiv = document.getElementById("history");
    const keys = Object.keys(allWeeks).filter(k => k !== META_WEEK_KEY).sort().reverse();
    histDiv.innerHTML = "";

    const t = document.createElement("table");
    t.innerHTML = `
      <thead>
        <tr>
          <th>Week</th>
          <th>Assigned</th>
          <th>Done</th>
          <th>Away</th>
        </tr>
      </thead>
    `;
    const tb = document.createElement("tbody");

    for (const wk of keys) {
      const w = allWeeks[wk];
      const totA = (w.assignments || []).reduce((s,a)=>s+a.pts,0);
      const totD = (w.assignments || []).reduce((s,a)=> s + ((w.done && w.done[a.taskKey]) ? a.pts : 0), 0);
      const away = (w.absent || []).join(", ");

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><span class="mono">${wk}</span>${wk === lastFinishedWeekKey(allWeeks, currentWeekKey) ? ' <span class="muted small">(last finished)</span>' : ''}</td>
        <td><b>${totA}</b></td>
        <td><b>${totD}</b></td>
        <td class="muted small">${away || "-"}</td>
      `;
      tb.appendChild(tr);
    }

    t.appendChild(tb);
    histDiv.appendChild(t);
  }

  /** =======================
   *  Boot: ensure meta + ensure current week exists (create-once)
   *  ======================= */
  async function ensureMetaExists(allWeeks) {
    ensureMetaLocal(allWeeks);
    if (allWeeks[META_WEEK_KEY] && Object.keys(allWeeks[META_WEEK_KEY]).length) return;

    // try read
    try {
      const state = await fetchWeekState(META_WEEK_KEY);
      allWeeks[META_WEEK_KEY] = state;
      ensureMetaLocal(allWeeks);
      return;
    } catch (e) {}

    // insert once
    const err = await insertWeekOnce(META_WEEK_KEY, allWeeks[META_WEEK_KEY]);
    if (err) {
      // someone else inserted -> read
      const state = await fetchWeekState(META_WEEK_KEY);
      allWeeks[META_WEEK_KEY] = state;
      ensureMetaLocal(allWeeks);
    }
  }

  async function ensureCurrentWeek(allWeeks, weekKey) {
    if (allWeeks[weekKey]) return;

    // try read
    try {
      const state = await fetchWeekState(weekKey);
      allWeeks[weekKey] = state;
      return;
    } catch (e) {}

    // create state
    const stateToInsert = buildWeekState(allWeeks, weekKey);

    // insert once (create-once)
    const err = await insertWeekOnce(weekKey, stateToInsert);
    if (!err) {
      allWeeks[weekKey] = stateToInsert;
      return;
    }

    // insert failed -> read canonical
    const canonical = await fetchWeekState(weekKey);
    allWeeks[weekKey] = canonical;
  }

  async function recomputeWeekOverwrite(allWeeks, weekKey) {
    if (!isAdmin()) throw new Error("Admin only");
    const existing = allWeeks[weekKey] || await fetchWeekState(weekKey);
    // keep absent list, keep done but prune invalid keys
    allWeeks[weekKey] = existing;
    const newState = buildWeekState(allWeeks, weekKey);
    newState.absent = existing.absent || [];
    await upsertWeek(weekKey, newState);
    allWeeks[weekKey] = newState;
  }

  async function saveAbsencesAndRecompute(allWeeks, weekKey, absentNow) {
    if (!isAdmin()) throw new Error("Admin only");

    // 1) attach absences to week
    const state = allWeeks[weekKey] || await fetchWeekState(weekKey);
    state.absent = absentNow;

    // 2) returners -> set done score to avg(done of others present)
    setReturnersToAverageDone(allWeeks, weekKey, absentNow);
    await saveMeta(allWeeks);

    // 3) recompute week using updated absences
    allWeeks[weekKey] = state;
    const newState = buildWeekState(allWeeks, weekKey);
    newState.absent = absentNow;

    await upsertWeek(weekKey, newState);
    allWeeks[weekKey] = newState;
  }

  /** =======================
   *  Main
   *  ======================= */
  async function main() {
    setStatus("Loadingâ€¦");
    const weekKey = isoWeekKey(new Date());
    let allWeeks = await fetchAllWeeks();
    await ensureMetaExists(allWeeks);
    await ensureCurrentWeek(allWeeks, weekKey);

    // Admin-only UI
    const admin = isAdmin();
    document.getElementById("absencesPanel").style.display = admin ? "" : "none";

    // Recompute button: admin only (and potentially destructive)
    const genBtn = document.getElementById("btnGenerate");
    genBtn.disabled = !admin;
    genBtn.textContent = admin ? "Recompute this week (admin)" : "Locked (admin only)";

    setStatus("OK (synced)");
    render(weekKey, allWeeks);

    // Admin recompute
    genBtn.onclick = async () => {
      if (!isAdmin()) return alert("Admin only.");
      const ok = confirm("This will recompute the schedule for the current week and may change assignments. Continue?");
      if (!ok) return;

      setStatus("Recomputingâ€¦");
      try {
        allWeeks = await fetchAllWeeks();
        await ensureMetaExists(allWeeks);
        await recomputeWeekOverwrite(allWeeks, weekKey);
        setStatus("OK (recomputed)");
        render(weekKey, allWeeks);
      } catch (e) {
        console.error(e);
        setStatus("Recompute error");
        alert("Error: could not recompute. See console.");
      }
    };

    // Save absences
    const saveAbsBtn = document.getElementById("btnSaveAbsences");
    if (saveAbsBtn) {
      saveAbsBtn.onclick = async () => {
        if (!isAdmin()) return alert("Admin only.");

        const absentNow = [];
        document.querySelectorAll("#absences input[type=checkbox]").forEach(cb => {
          if (cb.checked) absentNow.push(cb.dataset.person);
        });

        setStatus("Saving absencesâ€¦");
        try {
          allWeeks = await fetchAllWeeks();
          await ensureMetaExists(allWeeks);
          await saveAbsencesAndRecompute(allWeeks, weekKey, absentNow);
          setStatus("OK (absences saved)");
          render(weekKey, allWeeks);
        } catch (e) {
          console.error(e);
          setStatus("Absences error");
          alert("Error: could not save absences. See console.");
        }
      };
    }

    // Weekly recap copy
    document.getElementById("btnRecapCopy").onclick = async () => {
      try {
        allWeeks = await fetchAllWeeks();
        const text = buildWeeklyRecap(allWeeks, weekKey);
        await copyToClipboard(text);
        alert("Weekly recap copied to clipboard âœ…");
      } catch (e) {
        console.error(e);
        alert("Could not build recap. See console.");
      }
    };

    // Weekly recap WhatsApp
    document.getElementById("btnRecapWA").onclick = async () => {
      try {
        allWeeks = await fetchAllWeeks();
        const text = buildWeeklyRecap(allWeeks, weekKey);
        openWhatsAppShare(text);
      } catch (e) {
        console.error(e);
        alert("Could not build recap. See console.");
      }
    };

    // Export
    document.getElementById("btnExport").onclick = () => {
      const week = allWeeks[weekKey];
      const blob = new Blob([JSON.stringify({weekKey, roomKey: ROOM_KEY, state: week, meta: allWeeks[META_WEEK_KEY]}, null, 2)], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `coloc_${ROOM_KEY}_${weekKey}.json`;
      a.click();
      URL.revokeObjectURL(url);
    };

    // Realtime updates
    try {
      const channel = supabase.channel("coloc-weeks-realtime");
      channel.on(
        "postgres_changes",
        { event: "*", schema: "public", table: TABLE, filter: `room_key=eq.${ROOM_KEY}` },
        async () => {
          allWeeks = await fetchAllWeeks();
          render(weekKey, allWeeks);
          setStatus("OK (live update)");
        }
      );
      await channel.subscribe();
    } catch (e) {
      console.warn("Realtime not active", e);
    }
  }

  main().catch(e => {
    console.error(e);
    setStatus("Load error");
    alert("Error: check SUPABASE_URL / ANON_KEY / RLS policies.");
  });
</script>
</body>
</html>
